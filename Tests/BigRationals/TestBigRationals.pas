unit TestBigRationals;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework, System.Math, Velthuis.BigIntegers, Velthuis.BigRationals,
  Velthuis.BigDecimals, System.SysUtils;

type

  // Test methods for class BigRational
  TestBigRational = class(TTestCase)
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure TestCtorNumDenom;
    procedure TestCtorDouble;
    procedure TestCtorDouble2;
    procedure TestCtorBigDecimal;
    procedure TestAdd;
    procedure TestSubtract;
    procedure TestMultiply;
    procedure TestDivide;
    procedure TestIntDivide;
    procedure TestModulus;
    procedure TestDivMod;
    procedure TestNegative;
    procedure TestNegate;
    procedure TestReciprocal;
    procedure TestCompare;
  end;

implementation

procedure TestBigRational.SetUp;
begin
end;

procedure TestBigRational.TearDown;
begin
end;

{$I 'BigRationalTestData.inc'}

procedure TestBigRational.TestCtorNumDenom;
var
  I, J: Integer;
  A: BigRational;
  X, Y: BigInteger;
  S: string;
  N: Integer;
  TestInfo: TTestResult;
begin
  N := 0;
  for I := 0 to High(CtorTestData) do
  begin
    X := CtorTestData[I];
    for J := 0 to High(CtorTestData) do
    begin
      Y := CtorTestData[J];
      TestInfo := CtorResults[N];
      Inc(N);
      try
        A.Create(X, Y);
      except
        on EDivByZero do
        begin
          Check(TestInfo.Info = triDivideByZero, Format('(%d,%d) Unexpected division by zero exception: BigRational.Create(%s, %s)', [I, J, string(X), string(Y)]));
          Continue;
        end;
      end;
      Check(TestInfo.val = A.ToString, Format('(%d,%d) BigRational(%s, %s) = %s (%s)', [I, J, string(X), string(Y), string(A), S]));
    end;
  end;
end;

procedure TestBigRational.TestCtorBigDecimal;
var
  I: Integer;
  D: BigDecimal;
  R: BigRational;
begin
  for I := 0 to High(BigDecimalData) do
  begin
    D := BigDecimalData[I];
    R := BigRational.Create(D);
    Check(R.ToString = BigDecimalCtorResults[I].val, Format('(%d) BigRational.Create(BigDecimal(''%s'')) = %s (%s)', [I, BigDecimalData[I], R.ToString, BigDecimalCtorResults[I].val]));
  end;
end;

procedure TestBigRational.TestCtorDouble;
var
  I: Integer;
  InvalidArgumentRaised: Boolean;
  A: BigRational;
begin
  for I := 0 to High(DoubleData) do
  begin
    A := BigRational.Create(DoubleData[I]);
    Check(A.ToString = DoubleCtorResults[I].val, Format('(%d) %f --> ''%s'' (''%s'')', [I, DoubleData[I], string(A), DoubleCtorResults[i].val]));
  end;

  // Check for invalid arguments NegInfinity, Infinity and Nan
  InvalidArgumentRaised := False;
  try
    A := BigRational.Create(NegInfinity);
  except
    on E: EInvalidArgument do
      InvalidArgumentRaised := True;
  end;
  Check(InvalidArgumentRaised, 'Expected exception on BigRational.Create(NegInfinity)');
  InvalidArgumentRaised := False;
  try
    A := BigRational.Create(Infinity);
  except
    on E: EInvalidArgument do
      InvalidArgumentRaised := True;
  end;
  Check(InvalidArgumentRaised, 'Expected exception on BigRational.Create(Infinity)');
  InvalidArgumentRaised := False;
  try
    A := BigRational.Create(NaN);
  except
    on E: EInvalidArgument do
      InvalidArgumentRaised := True;
  end;
  Check(InvalidArgumentRaised, 'Expected exception on BigRational.Create(NaN)');
end;

procedure TestBigRational.TestCtorDouble2;
var
  Dbl: Double;
  Reslt: BigRational;
  I, J: Integer;
  X, Y, XR, YR: Int64;
begin
  for I := 0 to High(CtorTestData) do
  begin
    X := Int64(BigInteger(CtorTestData[I])) and $0000FFFFFFFFFFFF;
    if X <> 0 then
    begin
      for J := 0 to High(CtorTestData) do
      begin
        Y := Int64(BigInteger(CtorTestData[J])) and $0000FFFFFFFFFFFF;
        Dbl := Y / X;
        try
          Reslt := BigRational.Create(Dbl, 1e-15, 15);
        except
          on E: EOverflow do
            Continue;
        end;
        XR := Int64(Reslt.Denominator);
        YR := Int64(Reslt.Numerator);
        Check(((XR = X) and (YR = Y)) or (Abs(YR / XR - Dbl) <= BigRational.MinEpsilon),
          Format('(%d,%d) %d / %d (%.15g) --> %d / %d, (%.15g)', [I, J, Y, X, Y/X, YR, XR, YR/XR]));
      end;
    end;
  end;
end;

procedure TestBigRational.TestAdd;
var
  TestInfo: TTestResult;
  I, J, N: Integer;
  A, B, C: BigRational;
begin
  N := 0;
  for I := 0 to High(Arguments) do
  begin
    A := Arguments[I];
    for J := 0 to High(Arguments) do
    begin
      B := Arguments[J];
      TestInfo := AddResults[N];
      Inc(N);
      C := A + B;
      Check(TestInfo.Val = C.ToString, Format('(%d,%d) %s + %s = %s (%s)', [I, J, string(A), string(B), string(C), TestInfo.val]));
    end;
  end;
end;

procedure TestBigRational.TestSubtract;
var
  TestInfo: TTestResult;
  I, J, N: Integer;
  A, B, C: BigRational;
begin
  N := 0;
  for I := 0 to High(Arguments) do
  begin
    A := Arguments[I];
    for J := 0 to High(Arguments) do
    begin
      B := Arguments[J];
      TestInfo := SubtractResults[N];
      Inc(N);
      C := A - B;
      Check(TestInfo.Val = C.ToString, Format('(%d,%d) %s - %s = %s (%s)', [I, J, string(A), string(B), string(C), TestInfo.val]));
    end;
  end;
end;

procedure TestBigRational.TestMultiply;
var
  TestInfo: TTestResult;
  I, J, N: Integer;
  A, B, C: BigRational;
begin
  N := 0;
  for I := 0 to High(Arguments) do
  begin
    A := Arguments[I];
    for J := 0 to High(Arguments) do
    begin
      B := Arguments[J];
      TestInfo := MultiplyResults[N];
      Inc(N);
      C := A * B;
      Check(TestInfo.Val = C.ToString, Format('(%d,%d) %s * %s = %s (%s)', [I, J, string(A), string(B), string(C), TestInfo.val]));
    end;
  end;
end;

procedure TestBigRational.TestDivide;
var
  TestInfo: TTestResult;
  I, J, N: Integer;
  A, B, C: BigRational;
begin
  N := 0;
  for I := 0 to High(Arguments) do
  begin
    A := Arguments[I];
    for J := 0 to High(Arguments) do
    begin
      B := Arguments[J];
      TestInfo := DivideResults[N];
      Inc(N);
      try
        C := A / B;
      except
        Check(TestInfo.Info = triDivideByZero, Format('(%d,%d) Unexpected division by zero: %s / %s', [I, J, string(A), string(B)]));
        Continue;
      end;
      Check(TestInfo.Val = C.ToString, Format('(%d,%d) %s / %s = %s (%s)', [I, J, string(A), string(B), string(C), TestInfo.val]));
    end;
  end;
end;

procedure TestBigRational.TestIntDivide;
var
  TestInfo: TTestResult;
  I, J, N: Integer;
  A, B: BigRational;
  X: BigInteger;
begin
  N := 0;
  for I := 0 to High(Arguments) do
  begin
    A := Arguments[I];
    for J := 0 to High(Arguments) do
    begin
      B := Arguments[J];
      TestInfo := IntDivideResults[N];
      Inc(N);
      try
        X := A div B;
      except
        Check(TestInfo.Info = triDivideByZero, Format('(%d,%d) Unexpected division by zero: %s / %s', [I, J, string(A), string(B)]));
        Continue;
      end;
      Check(TestInfo.Val = X.ToString, Format('(%d,%d) %s div %s = %s (%s)', [I, J, string(A), string(B), string(X), TestInfo.val]));
    end;
  end;
end;

procedure TestBigRational.TestModulus;
var
  TestInfo: TTestResult;
  I, J, N: Integer;
  A, B, C: BigRational;
begin
  N := 0;
  for I := 0 to High(Arguments) do
  begin
    A := Arguments[I];
    for J := 0 to High(Arguments) do
    begin
      B := Arguments[J];
      TestInfo := RemainderResults[N];
      Inc(N);
      try
        C := A mod B;
      except
        Check(TestInfo.Info = triDivideByZero, Format('(%d,%d) Unexpected division by zero: %s / %s', [I, J, string(A), string(B)]));
        Continue;
      end;
      Check(TestInfo.Val = C.ToString, Format('(%d,%d) %s mod %s = %s (%s)', [I, J, string(A), string(B), string(C), TestInfo.val]));
    end;
  end;
end;

procedure TestBigRational.TestDivMod;
var
  TestInfo1, TestInfo2: TTestResult;
  I, J, N: Integer;
  A, B, C: BigRational;
  X: BigInteger;
begin
  N := 0;
  for I := 0 to High(Arguments) do
  begin
    A := Arguments[I];
    for J := 0 to High(Arguments) do
    begin
      B := Arguments[J];
      TestInfo1 := IntDivideResults[N];
      TestInfo2 := RemainderResults[N];
      Inc(N);
      try
        BigRational.DivMod(A, B, X, C);
      except
        Check(TestInfo1.Info = triDivideByZero, Format('(%d,%d) Unexpected division by zero: %s / %s', [I, J, string(A), string(B)]));
        Continue;
      end;
      Check(TestInfo1.Val = X.ToString, Format('(%d,%d) %s div %s = %s (%s)', [I, J, string(A), string(B), string(X), TestInfo1.val]));
      Check(TestInfo2.Val = C.ToString, Format('(%d,%d) %s mod %s = %s (%s)', [I, J, string(A), string(B), string(C), TestInfo2.val]));
    end;
  end;
end;

procedure TestBigRational.TestNegative;
var
  TestInfo: TTestResult;
  I: Integer;
  A, C: BigRational;
begin
  for I := 0 to High(Arguments) do
  begin
    A := Arguments[I];
    TestInfo := NegateResults[I];
    C := -A;
    Check(TestInfo.Val = C.ToString, Format('(%d) -(%s) = %s (%s)', [I, string(A), string(C), TestInfo.val]));
  end;
end;

procedure TestBigRational.TestNegate;
var
  TestInfo: TTestResult;
  I: Integer;
  A, C: BigRational;
begin
  for I := 0 to High(Arguments) do
  begin
    A := Arguments[I];
    TestInfo := NegateResults[I];
    C := A.Negate;
    Check(TestInfo.Val = C.ToString, Format('(%d) (%s).Negate = %s (%s)', [I, string(A), string(C), TestInfo.val]));
  end;
end;

procedure TestBigRational.TestReciprocal;
var
  TestInfo: TTestResult;
  I: Integer;
  A, C: BigRational;
begin
  for I := 0 to High(Arguments) do
  begin
    A := Arguments[I];
    TestInfo := ReciprocalResults[I];
    try
      C := A.Reciprocal;
    except
      Check(TestInfo.info = triDivideByZero, Format('(%d) Expected division by zero: 1/(%s)', [i, string(A)]));
      Continue;
    end;
    Check(TestInfo.Val = C.ToString, Format('(%d) (%s).Reciprocal = %s (%s)', [I, string(A), string(C), TestInfo.val]));
  end;
end;

procedure TestBigRational.TestCompare;
var
  Right: BigRational;
  Left: BigRational;
begin
  // TODO: Setup method call parameters
//  ReturnValue := FBigRational.Compare(Left, Right);
  // TODO: Validate method results
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestBigRational.Suite);
end.

